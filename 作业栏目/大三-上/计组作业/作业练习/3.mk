1.1--写出产生 64位常量 0x 1122 3344 5566 7788 的RISV-V的汇编代码
并将该值存储在 寄存器x10中

解答：
lui x10,0x11223          //  0000 0000 1122 3000
addi x10,x10,0x344       //  0000 0000 1122 3344
slli x10,x10,32          //  1122 3344 0000 0000
lui x5,0x55667           //  0000 0000 5566 7000
addi x5,x5,0x788         //  0000 0000 5566 7788
add x10,x10,x5           //  1122 3344 5566 7788


1.2 编写RISC-V的汇编代码,使用lr.d/sc.d指令将一下C代码实现为原子“set max"操作
参数shvar包含共享变量的地址

void setmax(int *shvar,int x){
	if(x>*shvar)
		*shvar=x;

}

解释：  try:
        lr.d x5,0(x10)           //将*schvar的值取出
        bge x5,x11, realese     //如果大于直接跳转至realease操作
		add x5,x11,0            //move x11,x5(x10)
		realese:
		sc.d x6,x5,0(x10)       //存储至*schvar
		bne  x6,x0,try          //返回至最开始

		jalr x0,x1              //return 0,返回一个地址x1


    
1.3--用 RISC-V 汇编语言编写一个程序，将包含十进制正整数或负整数字符串的
ASCII 字符串转换为整数。要求程序用寄存器 x10 保存一个以空字符结尾的字符
串的地址，该字符串包含一个可选的“+”或“-”,后跟一些 0 到 9 的数字组合。
要求程序计算与这个数字字符串相等的整数值，然后将数字放人寄存器 x10 中。
如果字符串中的任何位置出现非数字字符，则程序停止并将值-1 存入寄存器 x10
中。
例如，如果寄存器 x10 指向三个字节 5010、5210、010(以空字符结尾的字符
串“24”)的序列，则当程序停止时，寄存器 x10 应包含值 2410。RISC-V 的 mul
指令将两个寄存器作为输入。没有“muli”指令。因此,只需将常数 10 存储在
寄存器中。

解答：
    a_to_int:
	        addi x28,x0,10         //做一个乘法需要,判断是否为数字
			addi x29,x0,0         //存放总和 ,每次*10
			addi x5,x0,1          //判断是否为 '+'/'-'

			//判断是否为正负
			lbu x6,0(x10)         //取出第一个字符
			addi x7,x0,45         //存放'-'的accii
			bne x6,x7,noneg       //如果判断是整数,则跳转至nonge
            add x5,x0,-1          //放入-
			addi x10,x10,1        //地址+1
			jal x0,main           //地址+1

			noneg:
			 addi x7,x0,43        //'+'符号
			 bne x6,x7,main       //若是整数 且 无符号整数
			 add x10,x10,1        //地址加1, arry[1]

			 main:
			 lbu x6,0(x10)        //取出第二个字符
			 beq x6,x0,done       //空字符'/0'结尾
             addi x7,x0,48        //'0'
			 sub x6, x6,x7        //相减
			 blt x6,x0,fail       //小于0,遇到非字符
             bge x6,x28,fail      //如果>=10的,费字符

			 mul x29,x29,x28      //先乘以*10,以便后续加入
			 add x29,x29,x6       //加和进去,例如每次:sum= 2*10(原)+4 == 24
			 addi x10,x10, 1      //arry[2]
			 jal x0,main

			 done:                //结束最终加和的条件
			 addi x10,x29,0       //最终结果
			 mul x10,x10,x5       //给予符号
			 jalr x0,x1           //return 0
 
             fail:                //若中途出现非字符则返回-1
			 addi x10,x0,-1
			 jalr x0,x1




1.4 ---编译实现 sort 过程
 sort: 
       addi sp,sp,-40   //保存5个栈的位置
	   sd x1,32(sp)
	   sd x22,24(sp)
	   sd x21,16(sp)
	   sd x20,8(sp)
	   sd x19,0(sp)

  mv x21,x10            //i
  mv x22,x11            //j

  li x19,0
  forlist1:                   //外循环
       bge x19,x22,exit1      //退出外层循环
	   addi x20,x19,-1        //递减
  forlist2:
       blt x20,x0,exit2       //退出内层
	   slli x5,x20,3          //左移3位
	   add x5,x21,x5          //偏移地址

	   ld x6,0(x5)            //V[j]
	   ld x7,8(x5)            //V[j+1]

	   ble x6,x7,exit2        //跳出swap,进行内循环
       //传递参数的操作
	   mv x10,x21             //将v传入
	   mv x11,x20
	   jal x1,swap

	   addi x20,x20,-1        //j递减
	   j forlist2
	exit2:  addi x19,x19,1    //i+=1
	        j forlist1
    //恢复寄存器
	exit1:
	ld x19,0(sp)              //x19
	ld x20,8(sp)              //x20
	ld x21,16(sp)             //x21
	ld x22,24(sp)             //x22
	ld x1,32(sp)              //x1
	addi sp,sp,40             //原始栈顶

	jalr x0,x1                //程序结束


1.5--假设对于一个给定程序,70%的执行指令是算术指令10%是加载/存储指令20%
是分支指令。
(1)假设算术指令需要 2 周期，加载/存储指令需要 6 周期，而一条分支指令需
要 3 周期，求平均 CP1。
(2)对于性能提高 25%，如果加载/存储和分支指令都没有改进，一条算术指令
平均需要多少周期
(1) 解答：所执行的总时间周期数=0.7*n*2+0.1*n*6+0.2*n*3=2.6n
         平均CPI=总市州周期/总指令数=2.6
	解答：性能提高25%，若频率不变

	 CPI= 0.75*2.6=1.95
	 总时钟周期数=0.7*n*x+0.1*n*6+0.2*n*3=1.95n
	 x = CPI(aver) = 1.07

1.6--链接两个程序，请给出较为详细的链接步骤说

